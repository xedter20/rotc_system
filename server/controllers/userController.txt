import {
  addNetworkNode,
  getNetworkNode,
  getNetworkNodeByID,
  updateNetworkNodeByID
} from '../cypher/networkReg.js';
import {
  addPairingNode,
  checkIfMatchExist,
  checkIfPairExist,
  getAllMatchPairById,
  getAllParentNodes
} from '../cypher/transaction.js';
import {
  addUserQuery,
  createRelationShipQuery,
  detectPositionFromParent,
  detectPositionFromSponsor,
  findUserByEmailQuery,
  findUserByIdQuery,
  findUserByUserNameQuery,
  findUserQuery,
  getAllChildren,
  getChildren,
  getRootUser,
  getTreeStructureQuery,
  hasDirectConnection,
  matchBonusDataInsertionNode,
  matchBonusList,
  mergeUserQuery,
  updateMatchBonusListQuery
} from '../cypher/user.js';
import {
  alterFloaterData,
  createFloaterNode,
  fetchFloaterTuples,
  getFloaterData,
  listFloaterData,
  updateFloaterData,
  fetchFloaterToProcessInMatchSales,
  updateFloaterToProcessInMatchSales
} from '../cypher/floater.js';

import ShortUniqueId from 'short-unique-id';
import { codeTypeRepo } from '../repository/codeType.js';
import config from '../config.js';

import { incomeSalesRepo } from '../repository/incomeSales.js';
import { logging } from 'neo4j-driver';
import { packageRepo } from '../repository/package.js';
import { transformIntegers } from '../helpers/transfromIntegers.js';

import { v4 as uuidv4 } from 'uuid';

const { cypherQuerySession } = config;

const countTotalChildrenNodes = depthLevel => {
  return 1 * Math.pow(2, depthLevel);
};
const checkIfLeftOrRightOfParentNode = ({
  childNodeID,
  targetParentNodeID
}) => {};

checkIfLeftOrRightOfParentNode({
  firstParentDepthLevel: 4,
  targetParentDeptLevel: 3,
  // targetParentNodePosition: 2,
  currentNodeIndexPosition: 8
});

const getAllPossibleMatch = ({ depthLevel }) => {
  const countTotalChildrenNodes = depthLevel => {
    return 1 * Math.pow(2, depthLevel);
  };

  let childTotal = countTotalChildrenNodes(depthLevel);

  let countLeft = 0;
  let countRight = 0;
  let childrenSize = childTotal; //EXPECTED CHILDREN IN THE DEPTH LEVEL let combinations = [];
  let combinations = [];
  let combinations_ = [];
  let combinationsGeneral_ = [];
  let generalCount = 1;

  for (let index = 0; index < childrenSize; index++) {
    let last = index + 1;
    //Linear Prediction
    if (last % 2 === 0) {
      let leftAlias = `LVL_${depthLevel + 1}_INDEX_${index}`;
      let rightAlias = `LVL_${depthLevel + 1}_INDEX_${last}`;
      combinations.push([leftAlias, rightAlias]);
      // combinations.push(index + '=' + last);
    }

    if (depthLevel > 1) {
      //Left Prediction
      if (last % 2 === 1) {
        if (countLeft % 2 === 0) {
          let leftAlias = `LVL_${depthLevel + 1}_INDEX_${last}`;
          let rightAlias = `LVL_${depthLevel + 1}_INDEX_${last + 2}`;
          // combinations_.push(last + '=' + (last + 2));
          combinations_.push([leftAlias, rightAlias]);
        }
        countLeft++;
      }

      //Right Prediction
      if (last % 2 === 0) {
        if (countLeft % 2 === 1) {
          let leftAlias = `LVL_${depthLevel + 1}_INDEX_${last}`;
          let rightAlias = `LVL_${depthLevel + 1}_INDEX_${last + 2}`;
          // combinations_.push(last + '=' + (last + 2));
          combinations_.push([leftAlias, rightAlias]);
        }

        countRight++;
      }
    }
    //Parent Prediction
    if (index < childrenSize / 2) {
      let leftAlias = `LVL_${depthLevel + 1}_INDEX_${generalCount}`;
      let rightAlias = `LVL_${depthLevel + 1}_INDEX_${
        childrenSize - childrenSize / 2 + generalCount
      }`;

      combinationsGeneral_.push([leftAlias, rightAlias]);

      // combinationsGeneral_.push(
      //   generalCount + '=' + (childrenSize - childrenSize / 2 + generalCount)
      // );
      generalCount++;
    }
  }

  // //console.log('Combinations in Linear : ', combinations);
  // //console.log('Combinations in Left and Right: ', combinations_);

  let allCombinations = [...combinations, ...combinations_];
  if (childrenSize / 2 > 2) {
    allCombinations = [...allCombinations, ...combinationsGeneral_];
    // //console.log('Combinations in Parent', combinationsGeneral_);
  }

  return allCombinations;
};

const prepareDataBeforeInsertion = ({
  depthLevel,
  sourceIndexPosition,
  position
}) => {
  const createAlias = () => {
    let nextPositionIndex;
    let nextAlias = `LVL_${depthLevel + 1}`;
    if (position === 'LEFT') {
      let diff = sourceIndexPosition - 1;

      nextPositionIndex = sourceIndexPosition + diff;
      nextAlias = `${nextAlias}_INDEX_${nextPositionIndex}`;
    } else {
      let diff = sourceIndexPosition + 1 - 1;

      nextPositionIndex = sourceIndexPosition + diff;
      nextAlias = `${nextAlias}_INDEX_${nextPositionIndex}`;
    }

    return {
      nextPositionIndex,
      nextAlias
    };
  };

  // return createAlias({
  //   depthLevel: 1,
  //   sourceIndexPosition: 1,
  //   position: 'RIGHT'
  // });

  let allPossibleCombination = getAllPossibleMatch({ depthLevel });

  return {
    allPossibleCombination: allPossibleCombination,
    newlyAddedUserAlias: createAlias()
  };
};

const userDisplayIdGenerator = () => {
  const { randomUUID } = new ShortUniqueId({ length: 5 });
  let currentYear = new Date().getFullYear();

  let displayId = `AM_OPC-${currentYear}-${randomUUID()}`;
  // check if exists in db

  return displayId;
};
export const createUser = async (req, res, next) => {
  try {
    const data = req.body;

    const {
      firstName,
      lastName,
      email,
      position,
      parentNodeID,
      sponsorIdNumber,
      code,
      amulet_package,
      userName
    } = data;

    let isCodeValid = await codeTypeRepo.validateCode({
      code,
      userId: '',
      userPackageType: amulet_package
    });

    if (!isCodeValid) {
      throw Error('invalid_code');
    }

    let formData = {
      ...data,
      ID: uuidv4(),
      name: `${firstName} ${lastName}`,
      date_created: Date.now(),
      displayID: userDisplayIdGenerator()
    };

    var { records } = await cypherQuerySession.executeQuery(
      findUserByIdQuery(parentNodeID)
    );
    var [user] = transformIntegers(records[0]._fields[0]);

    let depthLevel = user?.DEPTH_LEVEL || 1;
    let sourceIndexPosition = user?.INDEX_PLACEMENT || 1;

    let nodeLogicProps = {};

    nodeLogicProps = prepareDataBeforeInsertion({
      depthLevel: depthLevel,
      sourceIndexPosition: sourceIndexPosition,
      position: position
    });

    formData = {
      ...formData,
      isRootNode: false,
      DEPTH_LEVEL: depthLevel + 1,
      ID_ALIAS: nodeLogicProps.newlyAddedUserAlias.nextAlias,
      INDEX_PLACEMENT: nodeLogicProps.newlyAddedUserAlias.nextPositionIndex,
      parentID: parentNodeID || ''
    };

    let { allPossibleCombination } = nodeLogicProps;
    var { records } = await cypherQuerySession.executeQuery(
      addUserQuery({
        ...formData,
        withEmail: !!email
      })
    );
    const [createdUser] = records[0]._fields;

    var { records } = await cypherQuerySession.executeQuery(
      findUserByIdQuery(sponsorIdNumber)
    );
    var [user] = records[0]._fields[0];
    let packageList = await packageRepo.listPackage();

    // amountInPhp points will be determine based
    // on newly registered member packageType
    let foundAmuletPackage = packageList.find(p => {
      return p.name === createdUser.amulet_package;
    });

    //
    let listCodeTypeList = await codeTypeRepo.listCodeType();
    let codeData = await codeTypeRepo.getCode(code);

    let foundType = listCodeTypeList.find(ct => {
      return ct.name === codeData.type;
    });

    let amountInPhp =
      foundType && foundType.hasDirectSponsorReferalBonus
        ? foundAmuletPackage.directReferalBonus
        : 0;

    await incomeSalesRepo.addIncome({
      type: 'DIRECT_REFERRAL',
      userID: data.sponsorIdNumber,
      dateTimeAdded: Date.now(),
      relatedEntityName: 'User',
      relatedEntityID: createdUser.displayID || createdUser.ID,
      amountInPhp,
      codeType: foundType.displayName
    });

    if (position && parentNodeID) {
      const result = createdUser.records[0]._fields[0];

      await cypherQuerySession.executeQuery(
        createRelationShipQuery({
          parentId: parentNodeID,
          ID: result.ID
        })
      );
    }
    // update code as used

    await codeTypeRepo.updateCodeByName({
      code,
      updateData: {
        status: 'USED',
        userID: createdUser.ID,
        directSponsorId: '',
        dateUsed: Date.now()
      }
    });

    res.status(200).json({
      success: true,
      message: 'created_successfully'
    });
    return true;
  } catch (error) {
    res.status(400).send({ message: error.message });
  }
};

export const getAllUsers = async (req, res, next) => {
  try {
    let userList = [];
    let loggedInUser = req.user;
    let filterSponsor = req.query.filterSponsor;

    if (loggedInUser.role === 'ADMIN') {
      let { records } = await cypherQuerySession.executeQuery(
        findUserQuery({
          sponsorIdNumber: false
        })
      );

      const users = records[0]._fields[0];

      userList = users;
    } else {
      let { records } = await cypherQuerySession.executeQuery(
        findUserByIdQuery(loggedInUser.ID)
      );

      const [user] = records[0]._fields[0];

      const childUserInfo = await cypherQuerySession.executeQuery(
        getAllChildren({
          ID: loggedInUser.ID
        })
      );

      let [childUser] = childUserInfo.records[0]._fields;

      if (filterSponsor) {
        userList = [user];
      } else {
        userList = childUser;
      }
    }

    let result = transformIntegers(
      userList.map(member => {
        let { password, ...otherProps } = member;
        return otherProps;
      })
    ).sort(function (a, b) {
      return new Date(b.date_created) - new Date(a.date_created);
    });

    res.status(200).send(result);
  } catch (error) {
    res.status(400).send(error.message);
  }
};

export const getMySponseelist = async (req, res, next) => {
  try {
    let loggedInUser = req.user;
    let userList = [];
    if (loggedInUser.role === 'ADMIN') {
      let { records } = await cypherQuerySession.executeQuery(
        findUserQuery({
          sponsorIdNumber: false
        })
      );

      const users = records[0]._fields[0];

      userList = users;
    } else {
      const sponsorIdNumber = loggedInUser.ID || req.params.sponsorIdNumber;

      let { records } = await cypherQuerySession.executeQuery(
        findUserQuery({
          sponsorIdNumber
        })
      );

      const users = records[0]._fields[0];

      userList = users.sort(function (a, b) {
        if (a.firstName < b.firstName) {
          return -1;
        }
        if (a.firstName > b.firstName) {
          return 1;
        }
        return 0;
      });
    }

    res.status(200).json({ success: true, data: transformIntegers(userList) });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

export const getUser = async (req, res, next) => {
  try {
    const userId = req.params.userId;
    let { records } = await cypherQuerySession.executeQuery(
      findUserByIdQuery(userId)
    );

    const [user] = records[0]._fields[0];

    res.status(200).json({
      success: true,
      data: user
    });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

export const isEmailExist = async (req, res, next) => {
  try {
    const email = req.body.email;

    // return array
    let { records } = await cypherQuerySession.executeQuery(
      findUserByEmailQuery(email)
    );

    const user = records[0]._fields[0];

    let isEmailExist = user && user.length > 0;

    res.status(200).json({
      success: true,
      isEmailExist: isEmailExist
    });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

export const isUserNameExist = async (req, res, next) => {
  try {
    const userName = req.body.userName;

    let { records } = await cypherQuerySession.executeQuery(
      findUserByUserNameQuery(userName)
    );

    const user = records[0]._fields[0];

    let isUserNameExist = user && user.length > 0;

    res.status(200).json({
      success: true,
      isUserNameExist: isUserNameExist
    });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

const recursiveUpdateAttributes = async (
  node,
  allPairingsFromDb,
  packageList
) => {
  // If the node is empty, just return it as is.

  if (!node) {
    return node;
  }

  let children;
  children = await Promise.all(
    (node.has_invite || []).map(async childNode => {
      let childNodeProps = await recursiveUpdateAttributes(
        childNode,
        allPairingsFromDb,
        packageList
      );

      return {
        ...childNodeProps,

        _id: node._id,

        has_invite: [],
        'has_invite.date_created': '',
        matchingPairs: allPairingsFromDb.filter(
          u => u.source_user_id === childNode.ID
        )
      };
    })
  );

  let userCodeDetails = await codeTypeRepo.getCodeByUserId(node.ID);

  let foundAmuletPackage = packageList.find(p => {
    return p.name === userCodeDetails.packageType;
  });

  return {
    INDEX_PLACEMENT: node.INDEX_PLACEMENT,
    codeType: userCodeDetails.type,
    name: node.name,
    packageType: foundAmuletPackage.displayName,
    _id: node._id,
    attributes: {
      ...node,
      INDEX_PLACEMENT: node.INDEX_PLACEMENT,
      _id: node._id,
      has_invite: [],
      'has_invite.date_created': ''
    },
    children: children.sort((a, b) => {
      let left = a.attributes?.position;
      let right = b.attributes?.position;

      if (left < right) {
        return -1;
      }
      if (left > right) {
        return 1;
      }
      return 0;
    }),
    has_invite: [],
    matchingPairs: allPairingsFromDb.filter(u => u.source_user_id === node.ID)
  };
};

export const getTreeStructure = async (req, res, next) => {
  try {
    // check if root has > 1 child
    let loggedInUser = req.user;
    let rootUserDetails = {};
    if (loggedInUser.role === 'ADMIN') {
      const rootNodeUser = await cypherQuerySession.executeQuery(getRootUser());

      if (rootNodeUser.records.length > 0) {
        let [rootUser] = rootNodeUser.records[0]._fields;

        rootUserDetails = rootUser[0];
        loggedInUser.ID = rootUserDetails.ID;
      }
    }

    const childUserInfo = await cypherQuerySession.executeQuery(
      getChildren({
        ID: loggedInUser.ID
      })
    );

    let [childUser] = childUserInfo.records[0]._fields;

    const data = await cypherQuerySession.executeQuery(
      getTreeStructureQuery({
        userId: loggedInUser.ID,
        withOptional: childUser.length == 0
      })
    );
    let result = transformIntegers(data.records[0]._fields);

    let getAllMatchPairByIdQuery = await cypherQuerySession.executeQuery(
      getAllMatchPairById({ ID: false })
    );

    let matchingPairs = getAllMatchPairByIdQuery.records[0]._fields[0];

    let packageList = await packageRepo.listPackage();

    let tree = await recursiveUpdateAttributes(
      result[0],
      matchingPairs,
      packageList
    );

    res.json({ success: true, data: tree });
  } catch (error) {
    //console.log(error);
    res.status(400).send(error.message);
  }
};

const getGiftCheque = async (
  matchListBonus,
  matchBonus,
  userID,
  position,
  triggeredFromUserID,
  relatedMatchBonusID,
  userIDToProcess
) => {
  let temp = 0;

  let insertDirectReferalSale = false;

  // let lastEntry = matchListBonus.sort((a, b) => {
  //   return new Date(b.dateTimeAdded) - new Date(a.dateTimeAdded);
  // })[matchListBonus.length - 1];

  matchListBonus.forEach(element => {
    //console.log(element.matchBonusAmount);
    temp = temp + element.matchBonusAmount / 1000;
  });

  // //console.log({ matchListBonus });

  // //console.log({ lastEntry });
  // //console.log({ temp });
  var match_sale = 0;
  if (temp >= 5 && temp < 10) {
    // insert gift cheque
    //Insert Gift Cheque
    let GC = 1000;

    await incomeSalesRepo.addIncome({
      ID: uuidv4(),
      type: 'GIFT_CHEQUE',
      userID: userID,
      dateTimeAdded: Date.now(),
      relatedEntityName: 'User',
      relatedEntityID: Date.now(),
      amountInPhp: GC,
      triggeredFromUserID,
      relatedMatchBonusID
    });
    match_sale = matchBonus - GC;
    //Insert match_sale

    await incomeSalesRepo.addIncome({
      ID: uuidv4(),
      type: 'MATCH_SALES',
      userID: userID,
      dateTimeAdded: Date.now(),
      relatedEntityName: 'User',
      relatedEntityID: Date.now(),
      amountInPhp: match_sale,
      triggeredFromUserID,
      relatedMatchBonusID
    });

    matchListBonus.forEach(async element => {
      await updateMatchBonusList(element.transactionID, {
        isCounted: true
      });
    });

    let whatsLeft = 0;
    if (temp > 5 && temp < 10) {
      console.log('boom');

      console.log({ userIDToProcess });
      whatsLeft = temp - 5;
      await matchBonusDataInsertion({
        currentLeftPoints: 0,
        currentRightPoints: 0,
        positionFloaterFrom: '',
        positionFloaterTo: '',
        matchBonusAmount: whatsLeft * 1000,
        dateTimeCreated: Date.now(),
        isCounted: false,
        isGreaterThan5k: matchBonus > 5000,
        transactionID: uuidv4(),
        userID_processed: userIDToProcess,
        matchingPairUser: []
      });
    }

    insertDirectReferalSale = match_sale > 0;
  } else if (temp >= 10) {
    let GC = matchBonus * 0.2;
    await incomeSalesRepo.addIncome({
      ID: uuidv4(),
      type: 'GIFT_CHEQUE',
      userID: userID,
      dateTimeAdded: Date.now(),
      relatedEntityName: 'User',
      relatedEntityID: Date.now(),
      amountInPhp: GC,
      triggeredFromUserID,
      relatedMatchBonusID
    });
    match_sale = matchBonus - GC;
    //Insert match_sale
    await incomeSalesRepo.addIncome({
      ID: uuidv4(),
      type: 'MATCH_SALES',
      userID: userID,
      dateTimeAdded: Date.now(),
      relatedEntityName: 'User',
      relatedEntityID: Date.now(),
      amountInPhp: match_sale,
      triggeredFromUserID,
      relatedMatchBonusID
    });

    matchListBonus.forEach(async element => {
      await updateMatchBonusList(element.transactionID, {
        isCounted: true
      });
    });

    let whatsLeft = 0;
    if (temp > 10) {
      console.log('boom 10');
      whatsLeft = temp - 10;
      await matchBonusDataInsertion({
        currentLeftPoints: 0,
        currentRightPoints: 0,
        positionFloaterFrom: '',
        positionFloaterTo: '',
        matchBonusAmount: whatsLeft * 1000,
        dateTimeCreated: Date.now(),
        isCounted: false,
        isGreaterThan5k: matchBonus > 5000,
        transactionID: uuidv4(),
        userID_processed: userIDToProcess,
        matchingPairUser: []
      });
    }
    insertDirectReferalSale = match_sale > 0;
  } else {
    match_sale = matchBonus;
    await incomeSalesRepo.addIncome({
      ID: uuidv4(),
      type: 'MATCH_SALES',
      userID: userID,
      dateTimeAdded: Date.now(),
      relatedEntityName: 'User',
      relatedEntityID: Date.now(),
      amountInPhp: match_sale,
      triggeredFromUserID,
      relatedMatchBonusID
    });
    insertDirectReferalSale = match_sale > 0;
  }
  // if (insertDirectReferalSale) {
  // }
  return { insertDirectReferalSale, match_sale };
  //   //console.log('getGiftCheque  -  leftPoints < rightPoints)');

  //   if (leftPoints <= 5000) {
  //     //console.log('getGiftCheque  -  leftPoints < 5000');
  //     // 1k MATCH CONDITION
  //     let count = 0;
  //     // query to get all current <not Flagged
  //     // WITH  no "isCounted" field ?>
  //     // Tupples with statusType "DIFFERENCE" ;

  //     //console.log({ All_Current_Matches_Left, All_Current_Matches_Right });

  //     let tempCurrent_lowAmountList = [];
  //     let tempCurrent_lowAmountListL = [];
  //     let tempCurrent_lowAmountListR = [];

  //     // Filtering
  //     All_Current_Matches_Left.forEach(element => {
  //       if (element.amount < 5000) {
  //         tempCurrent_lowAmountList.push(element);
  //         tempCurrent_lowAmountListL.push(element);
  //       }
  //     });
  //     // All_Current_Matches_Right.forEach(element => {
  //     //   if (element.amount < 5000) {
  //     //     tempCurrent_lowAmountList.push(element);
  //     //     tempCurrent_lowAmountListR.push(element);
  //     //   }
  //     // });
  //     // COUNTING
  //     tempCurrent_lowAmountList.forEach(element => {
  //       if (element.amount > 1000) {
  //         let separate_count = element.amount / 1000;
  //         count = count + separate_count;
  //       } else {
  //         count = count + 1;
  //       }
  //     });
  //     // let separate_count_outside = leftPoints / 1000;
  //     // count = count + separate_count_outside;
  //     //console.log({ tempCurrent_lowAmountListL });
  //     //console.log({ count });
  //     if (leftPoints > rightPoints) {
  //       let temp = 0;
  //       if (rightPoints > 1000 && rightPoints < 5000) {
  //         temp = rightPoints - 1000;
  //       } else {
  //         temp = rightPoints;
  //       }
  //       let separate_count_outside = temp / 1000;
  //       count = count + separate_count_outside;
  //     }
  //     // //console.log({ count });
  //     // if (leftPoints <= 5000 && leftPoints = 1000) {
  //     //   count = count + 1;
  //     // }
  //     if (count === 5) {
  //       //Update and add isCounted : true
  //       tempCurrent_lowAmountListL.map(otherProps => {
  //         return { ...otherProps, isCounted: true };
  //       });

  //       // tempCurrent_lowAmountListR.map(otherProps => {
  //       //   return { ...otherProps, isCounted: true };
  //       // });

  //       //console.log('alterFloaterData 1');
  //       for (let leftFloater of tempCurrent_lowAmountListL) {
  //         await alterFloaterData(
  //           userID,
  //           leftFloater.childID,
  //           leftFloater,
  //           'LEFT'
  //         );
  //       }

  //       // for (let rightFloater of tempCurrent_lowAmountListR) {
  //       //   await alterFloaterData(
  //       //     userID,
  //       //     rightFloater.childID,
  //       //     rightFloater,
  //       //     'RIGHT'
  //       //   );
  //       // }
  //       //console.log('alterFloaterData 2');
  //       //Insert Gift Cheque
  //       let GC = 1000;
  //       await incomeSalesRepo.addIncome({
  //         type: 'GIFT_CHEQUE',
  //         userID: userID,
  //         dateTimeAdded: Date.now(),
  //         relatedEntityName: 'User',
  //         relatedEntityID: Date.now(),
  //         amountInPhp: GC
  //       });

  //       //console.log('executed giftcheque');

  //       let temp = 0;

  //       if (leftPoints > rightPoints) {
  //         temp = rightPoints;
  //       } else {
  //         temp = rightPoints - leftPoints;
  //       }
  //       let match_sale = temp - GC;
  //       //Insert match_sale
  //       await incomeSalesRepo.addIncome({
  //         type: 'MATCH_SALES',
  //         userID: userID,
  //         dateTimeAdded: Date.now(),
  //         relatedEntityName: 'User',
  //         relatedEntityID: Date.now(),
  //         amountInPhp: match_sale
  //       });
  //     } else {
  //       let match_sale = result;
  //       if (position !== 'LEFT') {
  //         match_sale = leftPoints;
  //       }
  //       //Insert match_sale
  //       await incomeSalesRepo.addIncome({
  //         type: 'MATCH_SALES',
  //         userID: userID,
  //         dateTimeAdded: Date.now(),
  //         relatedEntityName: 'User',
  //         relatedEntityID: Date.now(),
  //         amountInPhp: match_sale
  //       });
  //     }
  //   } else {
  //     //console.log('else - 2');
  //     // Greater than 1k MATCH CONDITION
  //     // Update Floater
  //     // updateQuery(currentInsertedFloater);

  //     //Insert Gift Cheque
  //     let GC = rightPoints * 0.2;
  //     await incomeSalesRepo.addIncome({
  //       type: 'GIFT_CHEQUE',
  //       userID: userID,
  //       dateTimeAdded: Date.now(),
  //       relatedEntityName: 'User',
  //       relatedEntityID: referenceID,
  //       amountInPhp: GC
  //     });

  //     let match_sale = rightPoints - GC;
  //     //Insert match_sale
  //     await incomeSalesRepo.addIncome({
  //       type: 'MATCH_SALES',
  //       userID: userID,
  //       dateTimeAdded: Date.now(),
  //       relatedEntityName: 'User',
  //       relatedEntityID: referenceID,
  //       amountInPhp: match_sale
  //     });
  //   }
  // };
};

export const createChildren = async (req, res, next) => {
  try {
    const data = req.body;

    const { position, parentNodeID, targetUserID, code } = data;

    let { records } = await cypherQuerySession.executeQuery(
      findUserByIdQuery(parentNodeID)
    );
    const [user] = transformIntegers(records[0]._fields[0]);
    let depthLevel = user?.DEPTH_LEVEL || 1;
    let sourceIndexPosition = user?.INDEX_PLACEMENT || 1;

    let nodeLogicProps = prepareDataBeforeInsertion({
      depthLevel: depthLevel,
      sourceIndexPosition: sourceIndexPosition,
      position: position
    });

    let childUserInfo = await cypherQuerySession.executeQuery(
      findUserByIdQuery(targetUserID)
    );

    let [childUser] = childUserInfo.records[0]._fields[0];

    await cypherQuerySession.executeQuery(
      createRelationShipQuery({
        parentId: parentNodeID,
        ID: targetUserID
      })
    );

    let formData = {
      email: childUser.email,
      isRootNode: false,
      DEPTH_LEVEL: depthLevel + 1,
      ID_ALIAS: nodeLogicProps.newlyAddedUserAlias.nextAlias,
      INDEX_PLACEMENT: nodeLogicProps.newlyAddedUserAlias.nextPositionIndex,
      parentID: parentNodeID || '',
      position: position,
      displayID: childUser.displayID
    };

    let createdUser = await cypherQuerySession.executeQuery(
      mergeUserQuery({
        ...formData,
        withEmail: true
      })
    );
    let networkID = uuidv4();
    if (position && parentNodeID && targetUserID) {
      let { amulet_package, ID, INDEX_PLACEMENT, parentID } = childUser;

      let packageList = await packageRepo.listPackage();
      let foundAmuletPackage = packageList.find(p => {
        return p.name === amulet_package;
      });

      if (foundAmuletPackage) {
        // create relationship parent -> child
        await cypherQuerySession.executeQuery(
          createRelationShipQuery({
            parentId: parentNodeID,
            ID: targetUserID
          })
        );

        let { points } = foundAmuletPackage;

        const checkParentNodeIfPairExistQuery =
          await cypherQuerySession.executeQuery(
            getAllParentNodes({ ID: targetUserID })
          );

        const [child, parents] =
          checkParentNodeIfPairExistQuery.records[0]._fields;

        let list_ParentsOfParents = await Promise.all(
          parents.map(async currentParent => {
            let userIDToProcess = currentParent.ID;
            var positionFromSelectedNetwork = position; // use the insertion position by default
            if (
              childUser.sponsorIdNumber === userIDToProcess ||
              childUser.parentID !== userIDToProcess
            ) {
              //get the first level children position
              positionFromSelectedNetwork = await checkChildPositonFromParent(
                childUser.ID,
                userIDToProcess,
                childUser.position
              );
            }

            return {
              ...currentParent,

              position: positionFromSelectedNetwork,
              isViewed: false,
              date_viewed: ''
            };
          })
        );

        // insertion

        let data = {
          ID: networkID,
          parentID: parentNodeID,
          childID: targetUserID,
          points,
          position,
          list_ParentsOfParents,
          list_ParentsOfParentsIDs: list_ParentsOfParents.map(({ ID }) => ID),
          date_created: Date.now()
        };

        await cypherQuerySession.executeQuery(addNetworkNode(data));
      }
    }

    // update codeV set status = 'USED'
    // await codeTypeRepo.updateCodeByName({
    //   code,
    //   updateData: {
    //     status: 'USED',
    //     userID: targetUserID,
    //     directSponsorId: ''
    //   }
    // });

    res.status(200).json({
      success: true,
      message: 'created_successfully',
      data: { networkID }
    });
    return true;
  } catch (error) {
    //console.log(error);
    res.status(400).send({ message: error.message });
  }
};
export const getUserNodeWithChildren = async (req, res, next) => {
  try {
    const ID = req.body.ID;

    const childUserInfo = await cypherQuerySession.executeQuery(
      getChildren({
        ID: ID
      })
    );
    let childUsers = childUserInfo.records[0]._fields;

    let availablePosition = [
      { value: 'LEFT', label: 'Left' },
      { value: 'RIGHT', label: 'Right' }
    ];

    if (childUsers[0].length > 0) {
      let maxIndex = childUsers
        .map(({ INDEX_PLACEMENT }) => {
          return INDEX_PLACEMENT || 1;
        })
        .sort(function (a, b) {
          return a + b;
        });

      if (maxIndex[0] % 2 === 0) {
        availablePosition = [{ value: 'LEFT', label: 'Left' }];
      } else {
        availablePosition = [{ value: 'RIGHT', label: 'Right' }];
      }
    }

    res.json({ success: true, data: availablePosition });
  } catch (error) {
    console.log(error);
    res.status(400).send(error.message);
  }
};

export const getNetworkNodeList = async (req, res, next) => {
  try {
    let loggedInUser = req.user;
    let childID = req.body.childID;

    if (loggedInUser.role === 'ADMIN') {
      const rootNodeUser = await cypherQuerySession.executeQuery(getRootUser());

      if (rootNodeUser.records.length > 0) {
        let [rootUser] = rootNodeUser.records[0]._fields;
        loggedInUser.ID = rootUser[0].ID;
      }
    }

    let { records } = await cypherQuerySession.executeQuery(
      getNetworkNode({
        parentID: loggedInUser.ID
      })
    );

    const list = transformIntegers(records[0]._fields[0]);

    console.log({ dex: list.length });
    // return true;

    let mapped = list.map((networkV, index) => {
      let parentID = networkV.parentID;

      let list_ParentsOfParentsCURRENT = JSON.parse(
        networkV.list_ParentsOfParents
      );

      return {
        ...networkV,
        list_ParentsOfParents: list_ParentsOfParentsCURRENT
      };
    });

    res.json({ success: true, data: mapped });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

export const fetchNetworkNode = async (req, res, next) => {
  try {
    let networkID = req.body.childID;

    let { records } = await cypherQuerySession.executeQuery(
      getNetworkNodeByID({
        ID: networkID
      })
    );

    const networkV = records[0]._fields[0];

    let list_ParentsOfParents = JSON.parse(networkV.list_ParentsOfParents);

    res.json({ success: true, data: mapped });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

const fetchCurrentPoints = async (
  mainPostion,
  floaterPosition,
  currentInsertedData,
  parentID
) => {
  let result = 0;

  let oldFloaterDataArray = [];
  let currentData = 0;

  var { records } = await cypherQuerySession.executeQuery(
    getFloaterData({
      parentID,
      floaterPosition
    })
  );
  oldFloaterDataArray = transformIntegers(records[0]._fields[0]);

  let originUserID = '';
  if (oldFloaterDataArray.length > 0) {
    currentData = oldFloaterDataArray[0].points;
    originUserID = oldFloaterDataArray[0].childID;
  } else {
    currentData = 0;
  }

  let oldPoints = currentData; //Query on Floater data based on the logged in user

  if (mainPostion === 'LEFT') {
    if (floaterPosition === 'LEFT') {
      let newPoints = currentInsertedData.points;
      result = oldPoints + newPoints;
    } else {
      result = oldPoints;
    }
  } else {
    if (floaterPosition === 'RIGHT') {
      let newPoints = currentInsertedData.points;
      result = oldPoints + newPoints;
    } else {
      result = oldPoints;
    }
  }

  return {
    originUserID,
    points: result
  };
};

export const fetchFloaterData = async (req, res, next) => {
  try {
    let loggedInUser = req.user;
    if (loggedInUser.role === 'ADMIN') {
      const rootNodeUser = await cypherQuerySession.executeQuery(getRootUser());

      if (rootNodeUser.records.length > 0) {
        let [rootUser] = rootNodeUser.records[0]._fields;
        loggedInUser.ID = rootUser[0].ID;
      }
    }

    let floaterPosition = req.body.floaterPosition;
    let { records } = await cypherQuerySession.executeQuery(
      listFloaterData({
        ID: loggedInUser.ID,
        floaterPosition
      })
    );
    const list = transformIntegers(records[0]._fields[0]);

    res.json({ success: true, data: list });
  } catch (error) {
    res.status(400).send(error.message);
  }
};

const updateNetworkParentsofParents = async ({ ID, userId }) => {
  let { records } = await cypherQuerySession.executeQuery(
    getNetworkNodeByID({
      ID
    })
  );

  const networkV = records[0]._fields[0];

  let list_ParentsOfParents = JSON.parse(networkV.list_ParentsOfParents);

  let updatedData = list_ParentsOfParents.map(u => {
    let isViewed;
    if (u.isViewed) {
      isViewed = true;
    } else {
      if (u.ID === userId) {
        isViewed = true;
      }
    }
    return {
      ...u,
      isViewed: isViewed,
      date_viewed: Date.now()
    };
  });

  // //console.log(ID);
  // //console.log(updatedData);

  await cypherQuerySession.executeQuery(
    updateNetworkNodeByID({
      ID,
      data: {
        list_ParentsOfParents: JSON.stringify(updatedData)
      }
    })
  );

  return true;
};

const matchBonusDataInsertion = async data => {
  await cypherQuerySession.executeQuery(matchBonusDataInsertionNode(data));
};

const listMatchBonus = async (userID_processed, isCounted, isGreaterThan5k) => {
  let { records } = await cypherQuerySession.executeQuery(
    matchBonusList(userID_processed, isCounted, isGreaterThan5k)
  );

  const result = records[0]._fields[0];

  if (result && result.length > 0) {
    return transformIntegers(result);
  } else {
    return [];
  }
};

const updateMatchBonusList = async (transactionID, data) => {
  await cypherQuerySession.executeQuery(
    updateMatchBonusListQuery(transactionID, data)
  );
};
const floaterDataInsertion = async ({
  floaterPosition,
  userID,
  insertData,
  currentPoints,
  actionType = 'INSERT',
  removedPoints = '',
  isRemoved,
  isCounted = false,
  status = false,
  codeType,
  fromUserID
}) => {
  let floaterID = uuidv4();

  if (codeType === 'REGULAR') {
    await cypherQuerySession.executeQuery(
      updateFloaterData({
        parentID: userID,
        floaterPosition,
        status
      })
    );
  }

  insertData = {
    ...insertData,
    ID: floaterID,
    points: currentPoints,
    floater_position: floaterPosition,
    status: !status,
    action_type: actionType,
    removedPoints,
    date_created: Date.now(),
    isCounted: currentPoints > 4000, // for gift chequeu
    codeType,
    userID // the one being processed
  };
  await cypherQuerySession.executeQuery(createFloaterNode(userID, insertData));

  return insertData.ID;
};

const checkChildPositonFromParent = async (
  childId,
  parentID,
  defaultPosition
) => {
  //  get the position of placement parent

  // if has direct connection

  //console.log({ childId, parentID });

  if (childId === parentID) {
    return defaultPosition;
  }

  let hasDirectConnectionQuery = await cypherQuerySession.executeQuery(
    hasDirectConnection(childId, parentID)
  );

  let hasDirectParentRelationShip =
    hasDirectConnectionQuery.records &&
    hasDirectConnectionQuery.records.length > 0;

  var position = '';

  if (hasDirectParentRelationShip) {
    let [details] = transformIntegers(
      hasDirectConnectionQuery.records[0]._fields
    );

    position = details.position;
  } else {
    //get the first level children position
    let detectPositionFromSponsorQuery = await cypherQuerySession.executeQuery(
      detectPositionFromSponsor(childId, parentID)
    );

    if (detectPositionFromSponsorQuery.records.length > 0) {
      let [details] = transformIntegers(
        detectPositionFromSponsorQuery.records[0]._fields
      );
      position = details.position;
    } else {
      position = defaultPosition;
    }
  }

  return position;
};

const getPositionOfUser = async userIDToProcess => {
  let positionFromSelectedNetwork;
  if (childUser.sponsorIdNumber === userIDToProcess) {
    //get the first level children position
    positionFromSelectedNetwork = await checkChildPositonFromParent(
      childUser.ID,
      userIDToProcess
    );
  } else if (childUser.parentID === userIDToProcess) {
    //get the insertion position
    // let directParentQuery = await cypherQuerySession.executeQuery(
    //   findUserByIdQuery(networkV.parentID)
    // );

    // let [directParentInfo] = directParentQuery.records[0]._fields[0];

    positionFromSelectedNetwork = networkV.position;
  } else {
    //get the user position
    let foundData = parentsToProcess.find(user => {
      return user.ID === userIDToProcess;
    });
    positionFromSelectedNetwork = foundData.position;
  }

  return positionFromSelectedNetwork;
};

export const createFloaterFunc = async networkID => {
  try {
    let ID = networkID;

    var { records } = await cypherQuerySession.executeQuery(
      getNetworkNodeByID({
        ID
      })
    );

    const networkV = transformIntegers([records[0]._fields[0]])[0]; // return object

    let childUserInfo = await cypherQuerySession.executeQuery(
      findUserByIdQuery(networkV.childID)
    );

    let [childUser] = childUserInfo.records[0]._fields[0];

    let parentID = networkV.parentID;

    let list_ParentsOfParents = JSON.parse(networkV.list_ParentsOfParents);

    let parentsToProcess = list_ParentsOfParents;
    for (let parent of parentsToProcess) {
      let userIDToProcess = parent.ID;

      // var positionFromSelectedNetwork = await checkChildPositonFromParent(
      //   childUser.ID,
      //   userIDToProcess
      // );
      // networkV.position = positionFromSelectedNetwork;
      let selectedNetWork = {
        ...networkV,
        points: networkV.points,
        parentID: userIDToProcess
      };

      let insertData = {
        ID: uuidv4(),
        // floater_position: selectedNetWork.position,
        points: selectedNetWork.points,
        status: true,
        action_type: 'INSERT',
        date_created: Date.now(),
        earnings_inserted: 0,
        childID: networkV.childID
      };

      // console.log({
      //   processingParentID: userIDToProcess,
      //   position: selectedNetWork.position,
      //   parentName: parent.email
      // });
      var positionFromSelectedNetwork;
      var CONDITION = ``;

      if (childUser.sponsorIdNumber === userIDToProcess) {
        //get the first level children position
        positionFromSelectedNetwork = await checkChildPositonFromParent(
          childUser.ID,
          userIDToProcess
        );
        CONDITION = 'childUser.sponsorIdNumber === userIDToProcess';
      } else if (childUser.parentID === userIDToProcess) {
        //get the insertion position
        // let directParentQuery = await cypherQuerySession.executeQuery(
        //   findUserByIdQuery(networkV.parentID)
        // );

        // let [directParentInfo] = directParentQuery.records[0]._fields[0];

        positionFromSelectedNetwork = networkV.position;

        CONDITION = 'childUser.parentID === userIDToProcess';
      } else {
        //get the user position from createChildren func
        let foundData = parentsToProcess.find(user => {
          return user.ID === userIDToProcess;
        });
        positionFromSelectedNetwork = foundData.position;
        CONDITION = 'get the user position from createChildren';
      }

      selectedNetWork.position = positionFromSelectedNetwork;

      // console.log({
      //   email: parent.email,
      //   positionFromSelectedNetwork,
      //   CONDITION,
      //   pos: selectedNetWork.position
      // });

      let triggeredFromUserID = childUser.ID; // source/triggeredUser

      // console.log({ pos: selectedNetWork.position });
      if (selectedNetWork.position === 'LEFT') {
        // left to right matching
        let LEFT = await fetchCurrentPoints(
          selectedNetWork.position,
          'LEFT',
          selectedNetWork,
          selectedNetWork.parentID
        ); // to query

        let RIGHT = await fetchCurrentPoints(
          selectedNetWork.position,
          'RIGHT',
          selectedNetWork,
          selectedNetWork.parentID
        );

        let currentLeftPoints = LEFT.points;
        let currentRightPoints = RIGHT.points;
        let result = 0;

        let userCodeDetails = await codeTypeRepo.getCodeByUserId(childUser.ID);
        if (
          currentRightPoints > 0 &&
          userCodeDetails &&
          userCodeDetails.type !== 'FREE_SLOT'
        ) {
          result = currentRightPoints - currentLeftPoints;

          // if child is free slot code then result = 0 ; match sales =  0

          // RIGHT
          // var { records } = await cypherQuerySession.executeQuery(
          //   fetchFloaterTuples(userIDToProcess, 'RIGHT', 'DIFFERENCE', false)
          // );
          // var data = records[0]._fields[0];
          var All_Current_Matches_Right = [];
          // RIGHT

          if (result < 0) {
            let currentPoints = result * -1;
            //Insert the current points Right Floater
            //Insert Initial Data
            await floaterDataInsertion({
              floaterPosition: 'LEFT',
              userID: userIDToProcess,
              insertData,
              currentPoints: currentLeftPoints,
              actionType: 'INSERT',
              status: false,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            let floaterID = await floaterDataInsertion({
              floaterPosition:
                currentRightPoints > currentLeftPoints ? 'RIGHT' : 'LEFT',

              userID: userIDToProcess,
              insertData,
              currentPoints: 0,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            //End  Insert Data ==0 Left
            await floaterDataInsertion({
              floaterPosition:
                currentRightPoints > currentLeftPoints ? 'LEFT' : 'RIGHT',
              userID: userIDToProcess,
              insertData,
              currentPoints,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            // add sales
          } else {
            //Insert the current points left Floater

            //Insert Initial Data

            // if child is free slot code then currentLeftPoints = 0 ; match sales =  0

            await floaterDataInsertion({
              floaterPosition: 'LEFT',
              userID: userIDToProcess,
              insertData,
              currentPoints: currentLeftPoints,
              actionType: 'INSERT',
              status: false,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            // await cypherQuerySession.executeQuery(
            //   updateNetworkNodeByID({
            //     ID,
            //     data: {
            //       type: 'OLD'
            //     }
            //   })
            // );

            // await updateNetworkParentsofParents({
            //   ID,
            //   userId: userIDToProcess
            // });
            //End Insert Initial Data

            let currentPoints = result;

            await floaterDataInsertion({
              floaterPosition:
                currentLeftPoints > currentRightPoints ? 'LEFT' : 'RIGHT',
              userID: userIDToProcess,
              insertData,
              currentPoints,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            let floaterID = await floaterDataInsertion({
              floaterPosition:
                currentLeftPoints > currentRightPoints ? 'RIGHT' : 'LEFT',
              userID: userIDToProcess,
              insertData,
              currentPoints: 0,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });
            // after we insert difference
            // we add income sale
          }

          // //console.log('match');
          let matchBonus =
            currentLeftPoints < currentRightPoints
              ? currentLeftPoints
              : currentRightPoints;

          // where the points been user to create incomesales
          let point_A_User =
            currentLeftPoints < currentRightPoints
              ? LEFT.originUserID
              : RIGHT.originUserID;

          // let notUsedInMatchSalesNetworkSelection =
          //   LEFT.notUsedInMatchSalesNetwork || RIGHT.notUsedInMatchSalesNetwork;

          // LEFT
          // var { records } = await cypherQuerySession.executeQuery(
          //   fetchFloaterTuples(userIDToProcess, 'LEFT', 'DIFFERENCE', false)
          // );
          // var data = records[0]._fields[0];
          // var All_Current_Matches_Left = transformIntegers(data).map(
          //   floater => {
          //     return {
          //       childID: floater.childID, // mean the current ID of  ChildFloater
          //       floater_position: floater.floater_position,
          //       amount: floater.points
          //     };
          //   }
          // );

          // LEFT

          // 1. create vertex with match bonus
          let matchBonusID = uuidv4();

          await matchBonusDataInsertion({
            currentLeftPoints,
            currentRightPoints,
            positionFloaterFrom: 'LEFT',
            positionFloaterTo: 'RIGHT',
            matchBonusAmount: matchBonus,
            dateTimeCreated: Date.now(),
            isCounted: false,
            isGreaterThan5k: matchBonus > 5000,
            transactionID: matchBonusID,
            userID_processed: userIDToProcess,
            matchingPairUser: JSON.stringify([
              {
                match_A: point_A_User,
                match_B: triggeredFromUserID
              }
            ])
            // floaterIDToUpdate: notUsedInMatchSalesNetworkSelection.ID
          });
          // //console.log('inserted');
          // 2. read the list
          let matchListBonus = await listMatchBonus(
            userIDToProcess,
            false,
            false
          );

          // 3. perform giftCheque

          let SponsorshipSales = await getGiftCheque(
            matchListBonus,
            matchBonus,
            userIDToProcess,
            'LEFT',
            triggeredFromUserID,
            matchBonusID,
            userIDToProcess
          );

          // await incomeSalesRepo.addIncome({
          //   type: 'MATCH_SALES',
          //   userID: selectedNetWork.parentID,
          //   dateTimeAdded: Date.now(),
          //   relatedEntityName: 'User',
          //   relatedEntityID: childUser.ID,
          //   amountInPhp: matchBonus
          // });

          // parentID
          // userIDToProcess

          // get the position of child from the sponsorID

          // //console.log('LEFT');
          // //console.log('DIRECT_SPONSORSHIP_SALES_MATCH');

          var directPositionFromParent = await checkChildPositonFromParent(
            networkV.parentID,
            childUser.sponsorIdNumber,
            childUser.position
          );

          var directPositionFromSponsor = await checkChildPositonFromParent(
            childUser.ID,
            childUser.sponsorIdNumber,
            childUser.position
          );

          let isTheSamePosition =
            directPositionFromParent === directPositionFromSponsor;

          // check if directPositionFromParent have pair child

          // const getChildrenQuery = await cypherQuerySession.executeQuery(
          //   getChildren({
          //     ID: networkV.parentID
          //   })
          // );
          // var countTotalOfChildren = 0;
          // if (getChildrenQuery.records.length > 0) {
          //   let data = getChildrenQuery.records[0];
          //   const list = data._fields[0];
          //   countTotalOfChildren = list.length;
          // }

          // //console.log({
          //   position: selectedNetWork.position,
          //   userIDToProcess,
          //   sponsorIdNumber: childUser.sponsorIdNumber,
          //   toInsert: loggedInUser.ID === childUser.sponsorIdNumber,
          //   isTheSamePosition,
          //   countTotalOfChildren
          // });

          // console.log('LEFT match sale');

          if (isTheSamePosition && SponsorshipSales.insertDirectReferalSale) {
            //
            let { records } = await cypherQuerySession.executeQuery(
              findUserByIdQuery(userIDToProcess)
            );

            const [parentDetails] = records[0]._fields[0];

            let packageList = await packageRepo.listPackage();

            // select package by the inserting/new user /downline
            // let foundAmuletPackage = packageList.find(p => {
            //   return p.name === childUser.amulet_package;
            // });

            // insert DIRECT_SPONSORSHIP_SALES_MATCH
            let selectedType = incomeSalesRepo.incomeSalesType.find(
              ({ type }) => {
                return type === 'DIRECT_SPONSORSHIP_SALES_MATCH';
              }
            );
            let amount = selectedType.computation(SponsorshipSales.match_sale); // result === points

            await incomeSalesRepo.addIncome({
              type: 'DIRECT_SPONSORSHIP_SALES_MATCH',
              userID: parentDetails.sponsorIdNumber,
              dateTimeAdded: Date.now(),
              relatedEntityName: 'Floater',
              relatedEntityID: Date.now(),
              amountInPhp: amount,
              relatedMatchBonusID: matchBonusID
            });
          }
        } else {
          // insert new data to left floater
          // set the status of previos floater to false
          //Insert the current points left Floater

          // if (userCodeDetails && userCodeDetails.type !== 'FREE_SLOT') {
          //   // await cypherQuerySession.executeQuery(
          //   //   updateNetworkNodeByID({
          //   //     ID,
          //   //     data: {
          //   //       type: 'OLD'
          //   //     }
          //   //   })
          //   // );
          //   // await updateNetworkParentsofParents({
          //   //   ID,
          //   //   userId: userIDToProcess
          //   // });
          // } else {
          //   currentLeftPoints = 0;
          // }

          currentLeftPoints =
            userCodeDetails.type !== 'FREE_SLOT' ? currentLeftPoints : 0;

          await floaterDataInsertion({
            floaterPosition: 'LEFT',
            userID: userIDToProcess,
            insertData,
            currentPoints: currentLeftPoints,
            status: userCodeDetails.type !== 'FREE_SLOT',
            codeType: userCodeDetails.type,
            triggeredFromUserID
          });
        }
      } else {
        // //console.log({ POSITION: selectedNetWork.position });
        // right to left

        console.log('rightttt');
        let LEFT = await fetchCurrentPoints(
          selectedNetWork.position,
          'LEFT',
          selectedNetWork,
          selectedNetWork.parentID
        );
        let RIGHT = await fetchCurrentPoints(
          selectedNetWork.position,
          'RIGHT',
          selectedNetWork,
          selectedNetWork.parentID
        );

        let currentLeftPoints = LEFT.points;
        let currentRightPoints = RIGHT.points;
        let result = 0;

        let userCodeDetails = await codeTypeRepo.getCodeByUserId(childUser.ID);

        // console.log({ currentLeftPoints, ct: userCodeDetails.type });

        if (
          currentLeftPoints > 0 &&
          userCodeDetails &&
          userCodeDetails.type !== 'FREE_SLOT'
        ) {
          //console.log('Execute currentLeftPoints > 0 ');
          result = currentLeftPoints - currentRightPoints;

          // RIGHT
          // var { records } = await cypherQuerySession.executeQuery(
          //   fetchFloaterTuples(userIDToProcess, 'RIGHT', 'DIFFERENCE', false)
          // );
          // var data = records[0]._fields[0];
          var All_Current_Matches_Right = [];
          // RIGHT

          // console.log({ result });

          if (result < 0) {
            let currentPoints = result * -1;

            await floaterDataInsertion({
              floaterPosition: 'RIGHT',
              userID: userIDToProcess,
              insertData,
              currentPoints: currentRightPoints,
              actionType: 'INSERT',
              status: false,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            let floaterID = await floaterDataInsertion({
              floaterPosition:
                currentLeftPoints > currentRightPoints ? 'RIGHT' : 'LEFT',
              userID: userIDToProcess,
              insertData,
              currentPoints: 0,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            await floaterDataInsertion({
              floaterPosition:
                currentLeftPoints > currentRightPoints ? 'LEFT' : 'RIGHT',
              userID: userIDToProcess,
              insertData,
              currentPoints: currentPoints,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });
          } else {
            console.log('not lesser than 0');
            await floaterDataInsertion({
              floaterPosition: 'RIGHT',
              userID: userIDToProcess,
              insertData,
              currentPoints: currentRightPoints,
              actionType: 'INSERT',
              status: false,
              codeType: 'REGULAR',
              triggeredFromUserID
            });

            let currentPoints = result;

            await floaterDataInsertion({
              floaterPosition:
                currentLeftPoints > currentRightPoints ? 'LEFT' : 'RIGHT',
              userID: userIDToProcess,
              insertData,
              currentPoints,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });
            //Insert Difference == 0 left
            let floaterID = await floaterDataInsertion({
              floaterPosition:
                currentLeftPoints > currentRightPoints ? 'RIGHT' : 'LEFT',
              userID: userIDToProcess,
              insertData,
              currentPoints: 0,
              actionType: 'DIFFERENCE',
              status: true,
              codeType: 'REGULAR',
              triggeredFromUserID
            });
          }

          let matchBonus =
            currentRightPoints < currentLeftPoints
              ? currentRightPoints
              : currentLeftPoints;

          // where the points been user to create incomesales
          let point_A_User =
            currentRightPoints < currentLeftPoints
              ? RIGHT.originUserID
              : LEFT.originUserID;

          // let notUsedInMatchSalesNetworkSelection =
          //   RIGHT.notUsedInMatchSalesNetwork || LEFT.notUsedInMatchSalesNetwork;

          let matchBonusID = uuidv4();

          await matchBonusDataInsertion({
            positionFloaterFrom: 'RIGHT',
            positionFloaterTo: 'LEFT',
            matchBonusAmount: matchBonus,
            dateTimeCreated: Date.now(),
            isCounted: false,
            isGreaterThan5k: matchBonus > 5000,
            transactionID: matchBonusID,
            userID_processed: userIDToProcess,
            matchingPairUser: JSON.stringify([
              {
                match_A: point_A_User,
                match_B: triggeredFromUserID
              }
            ])
            // floaterIDToUpdate: notUsedInMatchSalesNetworkSelection.ID
          });

          //console.log('inserted');
          // 2. read the list
          let matchListBonus = await listMatchBonus(
            userIDToProcess,
            false,
            false
          );

          let SponsorshipSales = await getGiftCheque(
            matchListBonus,
            matchBonus,
            userIDToProcess,
            'RIGHT',
            triggeredFromUserID,
            matchBonusID,
            userIDToProcess
          );

          // LEFT
          // var { records } = await cypherQuerySession.executeQuery(
          //   fetchFloaterTuples(userIDToProcess, 'LEFT', 'DIFFERENCE', false)
          // );
          // var data = records[0]._fields[0];
          // var All_Current_Matches_Left = transformIntegers(data).map(
          //   floater => {
          //     return {
          //       childID: floater.childID, // mean the current ID of  ChildFloater
          //       floater_position: floater.floater_position,
          //       amount: floater.points
          //     };
          //   }
          // );

          // LEFT

          // await incomeSalesRepo.addIncome({
          //   type: 'MATCH_SALES',
          //   userID: selectedNetWork.parentID,
          //   dateTimeAdded: Date.now(),
          //   relatedEntityName: 'User',
          //   relatedEntityID: childUser.ID,
          //   amountInPhp: matchBonus
          // });
          //console.log('DIRECT_SPONSORSHIP_SALES_MATCH');
          //console.log('RIGHT_ directPositionFromParent');
          var directPositionFromParent = await checkChildPositonFromParent(
            networkV.parentID,
            childUser.sponsorIdNumber,
            childUser.position
          );

          //console.log('RIGHT_directPositionFromSponsor');

          //  get the position of placement parent
          var directPositionFromSponsor = await checkChildPositonFromParent(
            childUser.ID,
            childUser.sponsorIdNumber,
            childUser.position
          );

          let isTheSamePosition =
            directPositionFromParent === directPositionFromSponsor;

          // const getChildrenQuery = await cypherQuerySession.executeQuery(
          //   getChildren({
          //     ID: userIDToProcess
          //   })
          // );
          // var countTotalOfChildren = 0;
          // if (getChildrenQuery.records.length > 0) {
          //   let data = getChildrenQuery.records[0];
          //   const list = data._fields[0];
          //   countTotalOfChildren = list.length;
          // }

          console.log('RIGHT match sales');

          // console.log({ userIDToProcess, matchBonus });

          if (isTheSamePosition && SponsorshipSales.insertDirectReferalSale) {
            let { records } = await cypherQuerySession.executeQuery(
              findUserByIdQuery(userIDToProcess)
            );

            const [parentDetails] = records[0]._fields[0];

            let packageList = await packageRepo.listPackage();

            // let foundAmuletPackage = packageList.find(p => {
            //   return p.name === childUser.amulet_package;
            // });

            // insert DIRECT_SPONSORSHIP_SALES_MATCH
            let selectedType = incomeSalesRepo.incomeSalesType.find(
              ({ type }) => {
                return type === 'DIRECT_SPONSORSHIP_SALES_MATCH';
              }
            );
            let amount = selectedType.computation(SponsorshipSales.match_sale); // result === points

            await incomeSalesRepo.addIncome({
              ID: uuidv4(),
              type: 'DIRECT_SPONSORSHIP_SALES_MATCH',
              userID: parentDetails.sponsorIdNumber,
              dateTimeAdded: Date.now(),
              relatedEntityName: 'User',
              relatedEntityID: Date.now(),
              amountInPhp: amount,
              triggeredFromUserID
            });
          }
        } else {
          // //console.log('executed else');

          // if (userCodeDetails && userCodeDetails.type !== 'FREE_SLOT') {
          //   // await cypherQuerySession.executeQuery(
          //   //   updateNetworkNodeByID({
          //   //     ID,
          //   //     data: {
          //   //       type: 'OLD'
          //   //     }
          //   //   })
          //   // );
          //   // await updateNetworkParentsofParents({
          //   //   ID,
          //   //   userId: userIDToProcess
          //   // });
          // } else {
          //   currentRightPoints = 0;
          // }

          currentRightPoints =
            userCodeDetails.type !== 'FREE_SLOT' ? currentRightPoints : 0;

          await floaterDataInsertion({
            floaterPosition: 'RIGHT',
            userID: userIDToProcess,
            insertData,
            currentPoints: currentRightPoints,
            status: userCodeDetails.type !== 'FREE_SLOT',
            codeType: userCodeDetails.type,
            triggeredFromUserID
          });
        }
      }
    }

    return true;
  } catch (error) {
    console.log(error);
  }
};
export const createFloater = async (req, res, next) => {
  try {
    let ID = req.body.ID;

    // insert createFloaterFunc

    await createFloaterFunc(ID);
    res.json({ success: true });
  } catch (error) {
    console.log(error);
    res.status(400).send(error.message);
  }
};

export const redoTransaction = async (req, res, next) => {
  try {
    let userID = req.body.userID;

    let { records } = await cypherQuerySession.executeQuery(`
        MATCH (n:Network {
          childID: '${userID}'
         }) 
        
        return properties(n)
  
  `);

    if (records.length > 0) {
      const result = records[0]._fields[0];
      let list_ParentsOfParentsV = JSON.parse(result.list_ParentsOfParents);

      for (let parent of list_ParentsOfParentsV) {
        let userIDToProcess = parent.ID;
        let query = `

           MATCH (child:User {ID: '${userID}'})
           OPTIONAL MATCH(child) <-[has_invite_e:has_invite]-(parent:User
            {
              ID: '${userIDToProcess}'
            }
            )
           with child,has_invite_e

        
          OPTIONAL MATCH(u:User { ID: '${userIDToProcess}' })-[e:has_floater]-> (floaterV:Floater)
          -[:has_history]-> (childFloater:ChildFloater { childID: '${userID}'})  
          detach delete childFloater
          with child,has_invite_e, floaterV,childFloater

          OPTIONAL MATCH(floaterV)-[:has_history]-> (childFloaterToUpdate:ChildFloater )
          where childFloaterToUpdate.codeType = 'REGULAR' OR  childFloaterToUpdate.codeType IS NULL
          with *
          order by 
   
          childFloaterToUpdate.date_created DESC
          limit 1 
          set childFloaterToUpdate.status = false 


           with child,has_invite_e, floaterV,childFloater

          OPTIONAL  MATCH (incomeSales:IncomeSales {
              triggeredFromUserID: '${userID}'
          }) 
          
          where  (incomeSales.triggeredFromUserID = '${userID}' OR  incomeSales.userID = '${userID}' )
          AND 
           NOT incomeSales.type IN
          
          ['DAILY_BONUS','DIRECT_REFERRAL']

          with child,has_invite_e,childFloater,incomeSales

          OPTIONAL MATCH (a:IncomeSales{
            userID:  '${userID}',
            type:'DIRECT_SPONSORSHIP_SALES_MATCH'
          }
           )
          with child,has_invite_e,childFloater,incomeSales,a

          OPTIONAL MATCH (b:MatchSalesV{
            userID_processed:
           '${userID}'
          })
          with child,has_invite_e,childFloater,incomeSales,a,b
          delete a,b, incomeSales , has_invite_e


          SET child.parentID = ''
           
           return *
          `;
        await cypherQuerySession.executeQuery(query);
        console.log(query);
      }
      await cypherQuerySession.executeQuery(`
             MATCH (n:Network {
                childID: '${userID}'
            })
            
            delete n
        `);
    }

    await cypherQuerySession.executeQuery(`

    match (n:User) where not (n)--()
     set n.parentID = '' 

     with n 
    optional  MATCH(child
               {
                 ID: '${userID}'
               }
              
              ) <-[has_invite_e:has_invite]-(parent:User)

              set child.parentID = ''
         
            delete has_invite_e
        `);

    res.json({ success: true });
  } catch (error) {
    console.log(error);
  }
};

const recursiveUpdate = async (node, allPairingsFromDb) => {
  // If the node is empty, just return it as is.

  if (!node) {
    return node;
  }
  let parentNodeID = node.ID;
  let children;
  children = (node.has_invite || []).sort((a, b) => {
    let left = a.position;
    let right = b.position;

    if (left < right) {
      return -1;
    }
    if (left > right) {
      return 1;
    }
    return 0;
  });

  for (let childNode of children) {
    let networkID = uuidv4();
    let targetUserID = childNode.ID;
    let position = childNode.position;
    let childUserInfo = await cypherQuerySession.executeQuery(
      findUserByIdQuery(childNode.ID)
    );

    let [childUser] = childUserInfo.records[0]._fields[0];

    let { amulet_package, ID, INDEX_PLACEMENT, parentID } = childUser;

    let packageList = await packageRepo.listPackage();

    let foundAmuletPackage = packageList.find(p => {
      return p.name === amulet_package;
    });

    if (foundAmuletPackage) {
      // create relationship parent -> child
      // await cypherQuerySession.executeQuery(
      //   createRelationShipQuery({
      //     parentId: parentNodeID,
      //     ID: targetUserID
      //   })
      // );

      let { points } = foundAmuletPackage;

      const checkParentNodeIfPairExistQuery =
        await cypherQuerySession.executeQuery(
          getAllParentNodes({ ID: targetUserID })
        );

      const [child, parents] =
        checkParentNodeIfPairExistQuery.records[0]._fields;

      let list_ParentsOfParents = [];
      for (let currentParent of parents) {
        let userIDToProcess = currentParent.ID;
        var positionFromSelectedNetwork = position; // use the insertion position by default
        if (
          childUser.sponsorIdNumber === userIDToProcess ||
          childUser.parentID !== userIDToProcess
        ) {
          //get the first level children position
          positionFromSelectedNetwork = await checkChildPositonFromParent(
            childUser.ID,
            userIDToProcess,
            childUser.position
          );
        }

        list_ParentsOfParents.push({
          ...currentParent,

          position: positionFromSelectedNetwork,
          isViewed: false,
          date_viewed: ''
        });
      }

      // insertion

      let data = {
        ID: networkID,
        parentID: parentNodeID,
        childID: targetUserID,
        points,
        position,
        list_ParentsOfParents,
        list_ParentsOfParentsIDs: list_ParentsOfParents.map(({ ID }) => ID),
        date_created: Date.now()
      };

      let resuult = await cypherQuerySession.executeQuery(addNetworkNode(data));

      let networkIDFromDb = resuult.records[0]._fields[0].properties.ID;

      await createFloaterFunc(networkIDFromDb || networkID);
    }

    if (childNode.has_invite && childNode.has_invite.length > 0) {
      await recursiveUpdate(childNode, allPairingsFromDb);
    }

    // if (childNode.has_invite.length > 0) {
    //   await recursiveUpdate(childNode, allPairingsFromDb);
    // }
    // let childNodeProps = await recursiveUpdate(childNode, allPairingsFromDb);

    // return {
    //   ...childNodeProps,

    //   ID: node.ID,

    //   matchingPairs: allPairingsFromDb.filter(
    //     u => u.source_user_id === childNode.ID
    //   )
    // };
  }
};

export const traverseTreeStruc = async (req, res, next) => {
  try {
    // check if root has > 1 child
    let userId = req.body.userID;

    console.log(1);
    let deleteQuery = ` 
       MATCH (nt:Network) detach delete nt
       with *
       MATCH (ms:MatchSalesV) detach delete ms
      with *
       MATCH (cf:ChildFloater)  detach delete cf
          with *
      MATCH (n:IncomeSales) 
            where      
        NOT n.type IN
       ['DAILY_BONUS','DIRECT_REFERRAL']  detach delete n`;
    await cypherQuerySession.executeQuery(deleteQuery).then(async () => {
      console.log(2);
      const data = await cypherQuerySession.executeQuery(
        getTreeStructureQuery({
          userId: userId,
          withOptional: false
        })
      );
      let result = transformIntegers(data.records[0]._fields);

      let getAllMatchPairByIdQuery = await cypherQuerySession.executeQuery(
        getAllMatchPairById({ ID: false })
      );

      let matchingPairs = getAllMatchPairByIdQuery.records[0]._fields[0];

      let tree = await recursiveUpdate(result[0], matchingPairs);

      res.json({ success: true });
    });
  } catch (error) {
    console.log(error);
    res.status(400).send(error.message);
  }
};
